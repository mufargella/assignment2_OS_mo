LAB-5 CODE EXAMPLES AND EXPLANATIONS

EXERCISE 1: Using fork() in C (process_creation.c)

This program demonstrates process creation using the fork() system call.

Code Explanation:
- The fork() function creates a new process by duplicating the calling process.
- It returns 0 to the child process and the child's PID to the parent process.
- If fork() returns -1, it means the fork failed.

What it does:
1. Calls fork() to create a child process
2. The child process (pid == 0) prints its own PID
3. The parent process (pid > 0) prints its own PID
4. If fork fails (pid < 0), it prints an error message

This demonstrates how a single program can split into two separate processes running concurrently.


EXERCISE 5: Role of the Linker (file1.c and file2.c)

These two files demonstrate how the linker combines multiple object files into a single executable.

file1.c contains:
- A function hello() that prints "Hello from file1!"

file2.c contains:
- A declaration of the hello() function (forward declaration)
- The main() function that calls hello()

What it does:
1. file1.c defines the hello() function
2. file2.c declares and calls hello() from main()
3. Each file is compiled separately into object files
4. The linker combines both object files and resolves the hello() function reference
5. This creates a single executable program

This demonstrates separate compilation and linking.


EXERCISE 6: Role of the Loader (simple_program.c)

This is a simple program used to inspect the dynamic libraries loaded at runtime.

Code Explanation:
- A minimal C program that prints a message and exits

What it does:
1. Prints "This is a simple program."
2. Returns 0 to indicate successful execution

After compiling, we use the 'ldd' command to inspect which shared libraries 
are dynamically loaded when the program runs. This shows the loader's role 
in loading necessary libraries into memory before execution.


WHAT IS THE JOB OF THE LINKER?


The Linker is a program that takes one or more object files generated by a compiler 
and combines them into a single executable file, library, or another object file.

Key responsibilities of the Linker:

1. Symbol Resolution:
   - Resolves references to functions and variables across different object files
   - Matches function calls to their definitions
   - Ensures all symbols (functions, variables) are properly connected

2. Relocation:
   - Assigns final memory addresses to code and data
   - Adjusts all references to reflect these addresses
   - Combines multiple code and data sections into unified sections

3. Library Linking:
   - Links external libraries (static or dynamic) to the program
   - Resolves references to standard library functions (like printf)
   - Can perform static linking (library code included in executable) or 
     dynamic linking (library loaded at runtime)

4. Error Detection:
   - Reports undefined symbols (functions or variables that are called but not defined)
   - Reports duplicate symbol definitions
   - Validates that all necessary components are present

Example: When compiling file1.c and file2.c separately, the linker combines 
their object files and resolves the hello() function reference from file2.c 
to its definition in file1.c.


WHAT IS THE JOB OF THE LOADER?


The Loader is a part of the operating system that loads programs into memory 
and prepares them for execution.

Key responsibilities of the Loader:

1. Program Loading:
   - Reads the executable file from disk
   - Allocates memory space for the program
   - Loads the program code and data into allocated memory
   - Sets up the program's memory segments (code, data, stack, heap)

2. Dynamic Linking:
   - Loads shared/dynamic libraries required by the program
   - Resolves symbols from dynamic libraries at load time or runtime
   - Maps shared libraries into the process's address space
   - Examples: libc.so (C standard library), libm.so (math library)

3. Relocation (Runtime):
   - Adjusts addresses in the program for its actual load location
   - Handles position-independent code (PIC)
   - Updates pointers and references to reflect actual memory addresses

4. Initialization:
   - Sets up the program's runtime environment
   - Initializes the stack and heap
   - Sets up command-line arguments and environment variables
   - Transfers control to the program's entry point (main function)

Example: When we run ./simple_program, the loader:
- Loads the executable into memory
- Loads required shared libraries (shown by ldd command)
- Sets up the execution environment
- Starts program execution

The 'ldd' command shows which dynamic libraries the loader will load:
- linux-vdso.so.1 (virtual dynamic shared object)
- libc.so.6 (C standard library)
- ld-linux.so (dynamic linker/loader itself)
